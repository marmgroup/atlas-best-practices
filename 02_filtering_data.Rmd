---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Reducing Large-Scale Positioning Error by Filtering

## Prepare libraries {-}

Here we load some useful libraries, and the helper functions.

```{r prep_libs_02_01}
# to handle movement data
library(data.table)
library(atlastools)

# to plot
library(ggplot2)
library(patchwork)
```

```{r}
# source helper functions
source("R/helper_functions.R")
```


## Introducing Errors to the Data

Here we introduce three kinds of errors to the data:

1. Small-scale normally distributed errors at each position;

2. Large-scale error at a random 0.5% of positions;

3. A large-scale displacement of a sequence of 300 positions.

While the data are 10,000 positions at 1-second interval, we shall use only 5,000 of these.

```{r read_sim_data}
# read in the data
data <- fread("data/data_sim.csv")[5000:10000, ]
```

We add outliers at random to the data to demonstrate their removal.

```{r add_outlier}
# make a copy
data_copy <- copy(data)

# add a prolonged spike or reflection to 300 positions
data_copy[500:800, `:=`(x = x + 0.25,
                        y = y + 0.25)]

# add normal error
data_copy[, `:=`(x = do_add_error(x, std_dev = 0.01),
                 y = do_add_error(y, std_dev = 0.005))]

# add 100 outliers
data_copy <- do_add_outliers(data_copy, p_data = 0.005, std_dev = 0.1)
```

Save the data to which errors have been added.

```{r}
fwrite(data_copy, file = "data/data_errors.csv")
```

Define a palette with 4 colours for convenience.

```{r}
# define a four colour palette
pal <- RColorBrewer::brewer.pal(4, "Set1")
```

## Make Figure of Simulated Data

We make a figure of the canonical data (grey line) along with the artificially added error (grey points).

```{r}
# make figure of canonical data with added errors
figure_raw <-
  ggplot()+
  geom_point(data = data_copy,
            aes(x, y),
            col = "grey",
            alpha = 1,
            size = 0.2)+
  geom_path(data = data,
            aes(x, y),
            col = "grey20",
            alpha = 1)+
  ggthemes::theme_map()+
  coord_equal()+
  theme(axis.text = element_blank(),
        axis.title = element_blank(),
        legend.position = "none")+
    theme(plot.background = element_rect(fill = NA))+
  labs(colour = NULL)
```

## Filtering by spatial bounds

First we remove gross positioning errors using a bounding box filter using the function `atl_filter_bounds`. In this example, we show filtering only on the Y coordinate.
`atl_filter_bounds` takes coordinate ranges as two-element vectors of the lower and higher bound.
It is possible to pass one the bounds as `NA`, in which case, only the other bound is used for filtering, i.e., `y_range = c(NA, 1)` is equivalent to selecting all Y coordinates < 1.

`atl_filter_bounds` was initially designed to remove positions _inside_ a specific range, hence the argument `remove_inside`.
The default value of the argument is `FALSE`, and `atl_filter_bounds` is thus a bounding box filter.

```{r remove_outside_bbox, eval=FALSE}
# remove positions outside a bounding box
# NB: set remove_inside to FALSE
data_inside_bbox <- atl_filter_bounds(data = data_copy,
                                      y_range = c(0.5, 1),
                                      remove_inside = FALSE)
```

`atl_filter_bounds` is not vectorised, and if there are two or more bounds per coordinate (for instance, $x_1 \ldots x_2$, and $x_3_ \ldots x_4$), they must be passed in two different function calls.




```{r}
# plot data inside and outside bbox
fig_filter_bounds <-
  ggplot()+
  geom_point(data = data_inside_bbox,
             aes(x, y),
             col = pal[2],
             alpha = 1, size = 0.2)+
  geom_point(data = data_copy[!data_inside_bbox,
                              on = c("x", "y")],
             aes(x, y),
             col = pal[1],
             alpha = 0.5, size = 0.2)+
  geom_path(data = data,
            aes(x, y),
            col = "grey20",
            alpha = 1)+
  geom_hline(yintercept = c(0.5, 1),
             col = "grey",
             lty = 2)+
  ggthemes::theme_map()+
  theme(plot.background = element_rect(fill = NA))+
  coord_equal()

# wrap plots
plot_figure <-
  wrap_plots(list(figure_raw, fig_filter_bounds)) +
  plot_annotation(tag_levels = "a",
                  tag_prefix = "(",
                  tag_suffix = ")") &
  theme(plot.tag = element_text(face = "bold"))

plot_figure

ggsave(plot_figure, filename = "figures/fig_raw_bounds.png", 
       width = 170, height = 170, units = "mm")
```

## Removing point outliers: The non-movement approach

```{r example_remove_outliers, eval=FALSE}
# get speed and turning angle
data_copy[, `:=`(in_speed = atl_get_speed(data_copy,
                                          type = "in"),
                 out_speed = atl_get_speed(data_copy,
                                           type = "out"),
                 angle = atl_turning_angle(data_copy))]

```

Next we idenfify the 90th and 95th percentile of speed and turning angle. This is more general than identifying the limits of implausibility for each individual (since there may be inter-individual differences), let alone each species in a large dataset.

An alternative approach is to define a speed cutoff based on expert knowledge, and this is best suited to well studied species.

```{r}
# get 90 and 95 percentile of speed and turning angle
sapply(data_copy[, c("in_speed", "angle")], function(z) {
  quantile(z, probs = c(0.9, 0.95), na.rm = TRUE)
})
```

Finally, we remove positions whose incoming and outgoing speeds are both greater than the 95th speed percentile.

```{r}
# filter the copy by the 95th percentile
data_filtered <- atl_filter_covariates(data_copy,
    filters = c("(in_speed < 0.024 & out_speed < 0.024) | angle < 40"))
```

```{r}
# data plot
fig_outlier_remove <-
  ggplot()+
  geom_path(data = data_copy,
            aes(x, y),
            col = "grey",
            lwd = 0.2)+
  geom_point(data = data_copy[500:800, ],
             aes(x, y),
             shape = 2, col = pal[4])+
  geom_point(data = data_copy[!data_copy[500:800, ],
                              on = c("x", "y")],
             aes(x, y, 
                 col = (in_speed >= 0.03 & out_speed >= 0.03),
                 shape = (in_speed >= 0.03 & out_speed >= 0.03)),
             show.legend = F,
             alpha = 0.5)+
  geom_path(data = data,
            aes(x, y),
            col = "grey20",
            alpha = 1)+
  geom_path(data = data,
            aes(x, y),
            col = "grey20",
            alpha = 1)+
  ggthemes::theme_map()+
  scale_color_brewer(palette = "Set1", direction = -1)+
  scale_shape_manual(values = c(1, 19))+
  coord_equal()+
  theme(plot.background = element_rect(fill = NA))
```

## Reflections: Challenges to the non-movement approach

```{r}
# attempt to remove reflections
data_no_reflection <- atl_remove_reflections(data_with_reflection,
                          point_angle_cutoff = 10,
                          reflection_speed_cutoff = 0.024)
# get reflections
reflection <- data_with_reflection[!data_no_reflection,
                                         on = c("x", "y")]
reflection <- na.omit(reflection)
```

```{r}
# get plots
fig_reflection <-
  ggplot()+
    geom_path(data = reflection,
             aes(x, y),
             alpha = 1,
             col = "grey")+
  geom_point(data = reflection,
             aes(x, y),
             alpha = 0.5,
             col = pal[1],
             shape = 2)+
  geom_point(data = data_no_reflection,
             aes(x, y),
             alpha = 0.5,
             colour = pal[2],
             shape = 1,
             show.legend = F)+
  geom_path(data = data,
            aes(x, y),
            col = "grey20",
            alpha = 1)+
  ggthemes::theme_map()+
  coord_equal()+
  theme(plot.background = element_rect(fill = NA))

# wrap figures
plot_figure <- wrap_plots(list(fig_outlier_remove, 
                               fig_reflection)) +
  plot_annotation(tag_levels = "a",
                  tag_prefix = "(",
                  tag_suffix = ")") &
  theme(plot.tag = element_text(face = "bold"))

plot_figure

ggsave(plot_figure, filename = "figures/fig_correct_tracks.png", 
       width = 170, height = 170, units = "mm")
```

## Export data

```{r}
fwrite(data_no_reflection, file = "data/data_no_reflection.csv")
```

