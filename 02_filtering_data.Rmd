---
output: html_document
editor_options: 
  chunk_output_type: console
---

This section covers:

1. Simple spatio-temporal filtering of point data to remove gross positioning errors,

2. Filtering positions on covariates that may be associated with increased positioning error,

3. Filtering movement tracks using the 'non-movement' approach to remove implausible movement segments, and

4. The challenge of reflected positions, and how it can be addressed.

# Filtering data

## Prepare libraries {-}

```{r prep_libs_02_01}
# to handle movement data
library(data.table)
library(atlastools)

# to simulate movement
library(smoove)

# to generate a landscape
library(raster)
library(NLMR)

# strings
library(glue)

# to plot
library(ggplot2)
library(patchwork)
```

```{r}
# source helper functions
source("R/helper_functions.R")
```


## Introducing errors {-}

Here we read the simulated data in. The limits of the coordinates are 0 and 1, so we add a few extraneous coordinates within a plausible distance to demonstrate the basic forms of filtering. We also assign a fictional _NBS_ value ranging between 2 and 6 to demonstrate filtering on covariates. Finally, we introduce a 'reflection', a phenomenon that results when a TOA system's position likelihood estimator shifts the real position by a large distance for an extended duration.

```{r read_sim_data}
# read in the data
data <- fread("data/data_sim.csv")[5000:10000, ]
```

We add outliers at random to the data to demonstrate their removal.

```{r add_outlier}
# make a dopy
data_copy <- copy(data)

# add normal error
data_copy[, `:=`(x = do_add_error(x, std_dev = 0.01),
                 y = do_add_error(y, std_dev = 0.005))]
# add 100 outliers
data_copy <- do_add_outliers(data_copy, p_data = 0.005, std_dev = 0.1)
```

## Show data with errors

```{r}
# make list of data to plot
data_plot <- list(data, data_copy)

# make plot list
plots <- lapply(data_plot, function(df) {
  ggplot(data = df)+
    
    geom_path(aes(x, y),
              col = "red", 
              alpha = 1, lwd = 0.2)+
    geom_point(aes(x, y),
              col = "darkblue", 
              alpha = 0.1,
              shape = 16)+
    # coord_cartesian(xlim = c(0.5, 1),
    #                 ylim = c(0.5, 1)) +
    coord_equal()+
    theme_test()+
    theme(axis.text = element_blank(),
          axis.title = element_blank())
})

# wrap plots
plot_figure <- wrap_plots(plots) +
  plot_annotation(tag_levels = "a",
                  tag_prefix = "(",
                  tag_suffix = ")") &
  theme(plot.tag = element_text(face = "bold"))

plot_figure

# save figure
ggsave(plot_figure, filename = "figures/fig_add_errors.png",
       width = 185, height = 90, units = "mm")
```


## Filtering by spatial bounds

First we remove gross positioning errors using a bounding box filter, i.e., knowing or assuming the real bounds of the movement track (in this case, 0 -- 1), we remove all positions outside those bounds.

```{r remove_outside_bbox, eval=FALSE}
# remove positions outside a bounding box
# NB: set remove_inside to FALSE
data_inside_bbox <- atlastools::atl_filter_bounds(data = data_copy,
                                                  y_range = c(0.5, 1),
                                                  remove_inside = FALSE)
```

```{r}
# data to plot
data_plot <- list(data_copy, data_inside_bbox)

# make plots
plots <- lapply(data_plot, function(df) {
  ggplot()+
    
    geom_path(data = df,
              aes(x, y),
              col = "red", 
              alpha = 1, lwd = 0.2)+
    geom_point(data = df,
               aes(x, y),
              col = "darkblue", 
              alpha = 0.1,
              pch = 16)+
    theme_test()+
    coord_equal() +
    theme(axis.title = element_blank(),
          axis.text = element_blank())
})

# add elements
plots[[1]] <- plots[[1]] + 
  annotate(xmin = 0.5, xmax = 1,
           ymin = 0.5, ymax = 1,
           fill = NA, col = "black", 
           lty = 2, geom = "rect")+
  annotate(x = 0.5, y = 1.1, label = "(b)", 
           fontface = "bold", geom = "text", size = 4)

# wrap plots
plot_figure <- wrap_plots(plots) +
  plot_annotation(tag_levels = "a",
                  tag_prefix = "(",
                  tag_suffix = ")") &
  theme(plot.tag = element_text(face = "bold"))

plot_figure

ggsave(plot_figure, filename = "figures/fig_filter_bounds.png", 
       width = 185, height = 90, units = "mm")
```

## Removing point outliers: The non-movement approach

Bjorneraas et al. (2010) describe intuitive filtering steps for trajectories that are based in the biology of the study species (moose _Alces alces_ in their case). Briefly, this 'non-movement method' identifies implausible segments of a trajectory, and removes them. Here, we adopt elements of their method to identify and remove 'spikes' or point outliers in the movement track, i.e., positions which indicate an improbably fast and short excursion away from the real trajectory.

We begin by calculating the speed and turning angle along the track. For both metrics, the first value is set at `NA`, indicating that we do not know the position of the individual prior to the start of the trajectory. The turning angle is calculated using the cosine rule and requires three positions to yield a values; thus it has an `NA` at the very last position as well.

```{r example_remove_outliers, eval=FALSE}
# get speed and turning angle
data_copy[, `:=`(in_speed = atl_get_speed(data_copy,
                                          type = "in"),
                 out_speed = atl_get_speed(data_copy,
                                           type = "out"),
                 angle = atl_turning_angle(data_copy))]

```

Next we idenfify the 90th and 95th percentile of speed and turning angle. This is more general than identifying the limits of implausibility for each individual (since there may be inter-individual differences), let alone each species in a large dataset.
An alternative approach is to define a speed cutoff based on expert knowledge, and this is best suited to well studied species.

```{r}
# get 90 and 95 percentile of speed and turning angle
sapply(data_copy[, c("in_speed", "angle")], function(z) {
  quantile(z, probs = c(0.9, 0.95), na.rm = TRUE)
})
```

Finally, we remove positions whose incoming and outgoing speeds are both greater than the 95th speed percentile.

```{r}
# filter the copy by the 95th percentile
data_filtered <- atl_filter_covariates(data_copy,
            filters = c("(in_speed < 0.03 & out_speed < 0.03) | angle < 40"))
```

```{r}
# data plot
data_plot <- list(data_copy, data_filtered)

plots <- lapply(data_plot, function(df) {
  ggplot()+
     geom_path(data = df,
              aes(x, y),
              col = "red", 
              alpha = 1, lwd = 0.2)+
    geom_point(data = df,
               alpha = 0.1,
               aes(x, y, 
                   col = (in_speed >= 0.03 & out_speed >= 0.03)),
               shape = ifelse((df$in_speed >= 0.03 & df$out_speed >= 0.03), 
                              16, 1),
               show.legend = F)+
    scale_colour_manual(values = c("darkblue", "red"))+
    theme_test()+
    coord_equal()+
    theme(axis.title = element_blank(),
          axis.text = element_blank())
})

plot_figure <- wrap_plots(plots) +
  plot_annotation(tag_levels = "a",
                  tag_prefix = "(",
                  tag_suffix = ")") &
  theme(plot.tag = element_text(face = "bold"))

plot_figure
ggsave(plot_figure, filename = "figures/fig_filter_spikes.png", 
       width = 185, height = 90, units = "mm")
```

## Does removing point outliers help?

### Making error combinations

Point outliers in a trajectory can be boiled down to two parameters: (1) how many positions have been converted into point outliers or spikes, and (2) how large the spikes are relative to the scale of the movement track.

Here we create combinations of these parameters and create 25 replicates of each combination using the error generator on the imported simulated data.

```{r outlier_error_combinations}
# define unique values
p_outlier <- c(0.05)
ext_outlier <- c(0.01, 0.05, 0.1)
replicate <- seq_len(10)

# make combinations
param_c <- CJ(p_outlier, ext_outlier, replicate)
```


## Reflections: Challenges to the non-movement approach

A peculiar issue affecting TOA tracking systems is the phenomenon of ‘reflected’ positions, in which the estimated location is instantaneously displaced many hundreds of metres from the individual’s real position for some time, followed by a return to the real position.

These reflections cannot be resolved in the same way as spikes, since they consist of several points with very realistic speeds bookended by a pair with either an extreme incoming or outgoing speed.

A reflection looks like this:

```{r}
# make a copy of data with spikes removed
data_with_reflection <- copy(data_filtered)

# add a reflection
data_with_reflection[500:600, `:=`(x = runif(101, 1, 1.01),
                                   y = runif(101, 1, 1.01))]
```


Removing reflections involves using the phenomenon’s properties to first identify its bounds and then removing all positions between these bounds.

In some instances, the estimated location is instantaneously displaced from the real movement track for multiple consecutive timesteps in the sampling process, followed by a return to the real position.
Removing such prolonged spikes (which we call `reflections') using Bjorneraas and colleagues' approach (2010) would be ineffective --- the bounds of the reflection have either extreme incoming \textit{or} outgoing speeds, and there are no positions with both.
When encountering such data, users are advised to identify the bounds of the reflection as first step to removing them: the inner bound (where the position estimate first shifts away from the track) will have a high incoming speed ($v_i$), while the outer bound (after which the position estimate returns to the real track) will have a high outgoing speed ($v_o$).
We suggest locating the first reflected point $p_1$ by comparing the incoming speeds of the track positions ($v_i$) against the speed cutoff $S$.
An optional turning angle cutoff $A$ may be used if the track includes plausible fast transit segments.
The first position to satisfy this comparison $v_i > S$ AND $\theta > A$ can be considered the inner bound of the reflection and set as an `anchor point'.
The position after the anchor point with the highest outgoing speed $v_o$ (such that $v_o > S$) can be considered to be the outer bound of the reflection.
The positions between these bounds can be identified as a trajectory reflection and removed.
For a system-specific reasons and the pre-processing steps thus far, a reflection may not end before the last position in the movement track.
In such cases, the entirety of the track following the first anchor point should be removed, as it is better to exclude moderate chunks of data than to make inferences from unsound data.
Removing reflections is implemented in a convenient form in \texttt{atlastools} in the \texttt{{atl\_remove\_reflections}} function.

The procedure is as follows:

1. Identify positions with anomalous (usually extremely high) speeds and turning angles, as with spikes, and

2. Split the trajectory into pre- and post-anomaly segments, and the first position of the post-anomaly segment, which is the inner bound of the reflection, can be set as an anchor point.

3. The first position after the anchor point with an instantaneous outgoing speed >= the speed cutoff is set as the outer bound of the reflection.

4. The positions between these bounds can be identified as a trajectory reflection and removed, along with one position before and after the bounds for safety's sake.

This method is robust to variable displacement of the reflections from the real positions, and also to displacement in the real position of the individual itself.


```{r}
# attempt to remove reflections
data_no_reflection <- atl_remove_reflections(data_with_reflection,
                                              point_angle_cutoff = 10,
                                              reflection_speed_cutoff = 0.03)
```

```{r}
# data to plot
plot_data <- list(data_with_reflection, data_no_reflection)

# get plots
plots <- lapply(plot_data, function(df) {
  ggplot()+
    geom_path(data = df,
              aes(x, y),
              col = "red", 
              alpha = 1, lwd = 0.2)+
    geom_point(data = df,
               aes(x, y),
               alpha = 0.1,
               colour = "darkblue",
               shape = 16,
               show.legend = F)+
    scale_colour_manual(values = c("darkblue", "red"))+
    theme_test()+
    coord_equal()+
    theme(axis.title = element_blank(),
          axis.text = element_blank())
})

# wrap figures
plot_figure <- wrap_plots(plots) +
  plot_annotation(tag_levels = "a",
                  tag_prefix = "(",
                  tag_suffix = ")") &
  theme(plot.tag = element_text(face = "bold"))

plot_figure

ggsave(plot_figure, filename = "figures/fig_filter_reflection.png", 
       width = 185, height = 90, units = "mm")
```

## Export data

```{r}
fwrite(data_no_reflection, file = "data/data_no_reflection.csv")
```

