---
output: html_document
editor_options: 
  chunk_output_type: console
---
## Residence patches and their construction

We propose a simpler alternative which is to synthesise high frequency trajectories into ‘residence patches’ using an intuitive multi-step, multi-scale segmentation and clustering procedure based on first principles/prior knowledge of the species’ biology. The residence patch is defined as a spatio-temporally proximate sequence of consistent positions where the individual was stationary (as in Oudman et al. 2019). While there are sophisticated ways of identifying stationary points in a track (e.g. recursion analysis; Bracis et al. 2018), the simplest method is to subset data with low speeds. The residence patch method uses only three parameters to determine the appropriate clustering. 

First, the distance between consecutive positions is compared against the buffer radius, which is the maximum distance between two temporally consecutive positions p1 and p2 for them to be considered to be part of the same sequence. Sequences of positions meeting this criterion are clustered into ‘proto-patches’. Next, recognising that proto-patches might represent discontinuous sequences of a larger residence patch (e.g. due to missing data), the time and distance between consecutive proto-patches is compared against the temporal independence limit and the spatial independence limit respectively. Both time difference and distance are calculated from the last position of proto-patch q1 to the first position of the next proto-patch q2. If either of these criteria for independence are met, i.e., proto-patch q2 is located at a distance greater than the spatial independence limit from q1, or begins more than temporal independence limit time units after q1 ends, the two are considered independent. Only q1 takes its final form as a residence patch, while q2 and q3 are then assessed for independence; a proto-patch is always merged with the proto-patch before it if they are found to be non-independent. 

While this algorithm considers only spatio-temporal differences between proto-patches as criteria for being independent residence patches, it can be easily extended to compare differences in any variable against an appropriate parameter. This comparison may be between variables at the end and beginning of consecutive proto-patches, or it may be between the median values of the proto-patches as a whole. For example, the median residence time (Bracis et al. 2018) of consecutive proto-patches can be very different when individuals switch foraging modes, and this difference can be used to separate them into independent patches despite being spatially and temporally proximate.

Having classified the track into residence patches, it is useful to extract summary data which may be passed on to a statistical analysis. Simple metrics of interest to animal ecologists include the patch duration, the distance travelled within the patch, the displacement within the patch, the tortuosity of movement within the patch (the distance – displacement ratio), the displacement between consecutive patches, as well as the median coordinates of the patch. These may be supplemented by more advanced metrics, such as the total patch area (assuming the previously defined buffer radius around each position), and the patch circularity which is a measure of roundness (e.g. Polsby and Popper 1991). 

The latter spatial metrics require the patch positions to be converted into spatial objects and merged to correct for overlapping buffers. These multi-polygon spatial objects representing each patch can be combined into a convenient spatial object representing the individual’s entire trajectory as a string of residence patches with summary statistics as covariates. Further environmental covariates for these patches are easily extracted from raster or vector spatial data.

## Prepare libraries {-}

```{r prep_libs_02_01}
library(data.table)
library(atlastools)
library(ggplot2)
```

## Read data and classify

```{r}
# read in the data
data <- fread("data/data_sim.csv")[5000:10000, ]
data[, id := "a"]

# make residence patch
patch <- atl_res_patch(data, 
                       buffer_radius = 0.0001, 
                       lim_spat_indep = 0.02, 
                       lim_time_indep = 3)
# get spatial representation
patch_sf <- atl_patch_summary(patch_data = patch, 
                              which_data = "spatial", 
                              buffer_radius = 0.01)

# get summary data
patch_summary <- atl_patch_summary(patch_data = patch,
                                   which_data = "summary")
```

## Plot classified residence patches

```{r}
plot_patches <- ggplot()+
  geom_sf(data = patch_sf,
          colour = "NA",
          aes(fill = duration),
          show.legend = FALSE)+
  geom_point(data = data,
             aes(x, y),
             size = 0.1,
             alpha = 0.1)+
  geom_point(data = patch_summary,
             aes(x_median + 0.5, y_median),
             size = 5,
             shape = 21,
             fill = "grey")+
  annotate(geom = "text",
           x = patch_summary$x_median + 0.5, 
           y = patch_summary$y_median + 0.02,
           label = patch_summary$patch,
           col = "red")+
  annotate(geom = "text",
           x = patch_summary$x_median, 
           y = patch_summary$y_median + 0.02,
           label = patch_summary$patch,
           col = "red")+
  annotate(geom = "text",
           x = c(0.5, 1.1),
           y = 1,
           label = sprintf("(%s)", c("a", "b")),
           fontface = "bold")+
  geom_path(data = patch_summary,
            aes(x_median + 0.5, y_median),
            colour = "darkblue",
            arrow = arrow(angle = 10, 
                          type = "closed"))+
  scale_fill_viridis_c()+
  theme_void()

plot_patches

# save figure
ggsave(plot_patches, 
       filename = "figures/fig_residence_patch.png",
       width = 185, height = 185 * 2 / 3, units = "mm")
```

