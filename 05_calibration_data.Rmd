---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Processing calibration data

## Prepare libraries

```{r}
# load libs
library(data.table)
library(atlastools)
library(ggplot2)
library(patchwork)

# prepare a palette
pal <- RColorBrewer::brewer.pal(4, "Set1")
```

## Preliminary visualisation

```{r}
# read and plot example data
data <- fread("data/atlas1060_allTrials_annotated.csv")
data_raw <- copy(data)
# plot data
fig_data_raw <-
  ggplot(data)+
  geom_path(aes(x, y),
             col = "grey", alpha = 0.5, size = 0.3)+
  geom_point(aes(x, y),
             col = "steelblue", alpha = 0.2, size = 2)+
  ggthemes::theme_map()+
  coord_sf(crs = 32631)

# save figure
ggsave(fig_data_raw, filename = "figures/fig_calibration_raw.png",
       width = 185 / 25)
```

## Filter by bounding box

Save an unprocessed copy.

```{r}
data_unproc <- copy(data)
```

Filter by a bounding box.

```{r}
# remove inside must be set to falses
data <- atl_filter_bounds(data = data, 
                          x = "x", y = "y", 
                          x_range = c(645000, max(data$x)), 
                          remove_inside = FALSE)
```

Plot the result.

```{r}
# plot data
fig_data_bbox <-
  ggplot()+
  geom_path(data = data_raw,
            aes(x, y),
             col = "grey", alpha = 0.5, size = 0.3)+
  geom_point(data = data_raw,
             aes(x, y,
                 col = x > 645000),
             alpha = ifelse(data_raw$x > 645000, 0.5, 1),
             size = ifelse(data_raw$x > 645000, 0.3, 2),
             show.legend = F)+
  scale_color_brewer(palette = "Set1")+
  geom_vline(xintercept = 645000,
             col = "grey", lty = 2)+
  ggspatial::annotation_scale(location = "br")+
  ggthemes::theme_map()+
  coord_sf(crs = 32631)

# save result
ggsave(fig_data_bbox, filename = "figures/fig_calib_bbox.png",
       width = 185 / 25)
```

### Remove low base station positions

```{r}
# save a copy
data_unproc <- copy(data)

# remove NBS <= 3
data <- atl_filter_covariates(data = data,
                              filters = "NBS > 3")
```

```{r}
fig_low_nbs <-
  ggplot()+
  geom_path(data = data,
            aes(x, y),
             col = "grey", alpha = 0.5, size = 0.3)+
  geom_point(data = data_unproc,
            aes(x, y,
                col = as.factor(NBS > 3)),
            shape = 1,
            alpha = 0.5, size = 0.3, show.legend = F)+
  scale_color_brewer(palette = "Set1")+
  ggthemes::theme_map()+
  ggspatial::annotation_scale(location = "tl")+
  coord_sf(crs = 32631)+
  labs(colour = "NBS")

# save figure
ggsave(fig_low_nbs, filename = "figures/fig_low_nbs.png",
       width = 185 / 25, height = 185 / 25)
```

## Filter trajectories

### Handle time

Time in ATLAS tracking is counted in milliseconds and is represented by a 64-bit integer (type `long`), which is not natively supported in R; it will instead be converted to a `numeric`, or `double`.

This is not what is intended, but it works. The `bit64` package can help handle 64-bit integers if you want to keep to intended type.

A further issue is that 64-bit integers (whether represented as `bit64` or `double`) do not yield meaninful results when you try to convert them to a date-time object, such as of the class `POSIXct`.

This is because `as.POSIXct` fails when trying to work with 64-bit integers (it cannot interpret this type), and returns a date many thousands of years in the future (approx. 52,000 CE) if the time column is converted to `numeric`.

There are two possible solutions. The parsimonious one is to convert the 64-bit number to a 32-bit short integer (dividing by 1000), or to use the `nanotime` package. 

The conversion method loses an imperceptible amount of precision. The `nanotime` requires installing another package. The first method is shown here. 

In the spirit of not destroying data, we create a second lower-case column called `time`.

```{r}
# divide by 1000, convert to integer, then convert to POSIXct
data[, time := as.POSIXct(as.integer(TIME / 1000), 
                          origin = "1970-01-01")]
```

### Add speed and turning angle

```{r}
# add incoming and outgoing speed
data[, `:=` (speed_in = atl_get_speed(data, 
                                      x = "x", 
                                      y = "y", 
                                      time = "time"),
             speed_out = atl_get_speed(data, type = "out"))]

# add turning angle
data[, angle := atl_turning_angle(data = data)]
```

### Get 95th percentile of speed and angle

```{r}
# use sapply
speed_angle_thresholds <- 
  sapply(data[, list(speed_in, speed_out, angle)], 
       quantile, probs = 0.9, na.rm = T)
```

### Plot to see speeds

```{r}
# plot filtered data
fig_speed_outliers <-
  ggplot()+
  geom_path(data = data,
            aes(x, y),
             col = "grey", alpha = 0.5, size = 0.3)+
  geom_point(data = data,
             aes(x, y, 
                 col = speed_in < 15.7),
             size = 0.3, alpha = 0.5,
             show.legend = F)+
  scale_color_brewer(palette = "Set1")+
  ggthemes::theme_map()+
  ggspatial::annotation_scale(location = "tl")+
  coord_sf(crs = 32631)+
  labs(colour = "speed (m/s)")

# save
ggsave(fig_speed_outliers, filename = "figures/fig_speed_outlier.png",
       width = 185 / 25, height = 185 / 25)
```

### Filter on speed

Here we use a speed threshold of 20 m/s, 4 m/s lower than the 95th percentile.

```{r}
# make a copy
data_unproc <- copy(data)

# remove speed outliers
data <- atl_filter_covariates(data = data,
            filters = c("(speed_in < 15.7 & speed_out < 15.7)"))

# recalculate speed and angle
data[, `:=` (speed_in = atl_get_speed(data, 
                                      x = "x", 
                                      y = "y", 
                                      time = "time"),
             speed_out = atl_get_speed(data, type = "out"))]

# add turning angle
data[, angle := atl_turning_angle(data = data)]
```

## Smoothing the trajectory

```{r}
# apply a 5 point median smooth, first make a copy
data_unproc <- copy(data)

# now apply the smooth
data <- atl_median_smooth(data = data,
                          x = "x", y = "y", time = "time",
                          moving_window = 5)
```

```{r}
# make figure
fig_smooth <-
  ggplot()+
  geom_path(data = data,
             aes(x, y),
            col = RColorBrewer::brewer.pal(4, "Set1")[4])+
  annotate(geom = "rect",
           xmin = c(650785, 650045),
           ymin = c(5904450, 5902700),
           xmax = c(652500, 650682),
           ymax = c(5906133, 5903080),
           fill = "grey90",
           alpha = 0.5,
           col = NA)+
    annotate(geom = "text",
           x = c(650785, 650045) + 400,
           y = c(5904450, 5902700) + 300,
           col = "black",
           label = c("d", "e"))+
  theme_void()+
  coord_sf(crs = 32631)+
  labs(colour = "track")

# make zoomed in figures
fig_inset <- mapply(function(xl, yl) {
  ggplot()+
    geom_point(data = data_raw[!data_unproc, on = c("x", "y")],
               aes(x, y),
               col = "grey",
               shape = 4,
               size = 0.4)+
    geom_point(data = data_unproc,
               aes(x, y),
               col = RColorBrewer::brewer.pal(3, "Set1")[3],
               shape = 1, 
               alpha = 0.5)+
    geom_path(data = data,
              aes(x, y),
              col = RColorBrewer::brewer.pal(4, "Set1")[4])+
    ggthemes::theme_few()+
    theme(axis.title = element_blank(),
          axis.text = element_blank())+
    ggspatial::annotation_scale(location = "br")+
    coord_cartesian(
             xlim = xl,
             ylim = yl, expand = F
             )+
    labs(colour = "track")
}, list(xl1 = c(650785, 652500),
        xl2 = c(650045, 650682)),
   list(yl1 = c(5904450, 5906133),
        yl2 = c(5902700, 5903080)),
SIMPLIFY = FALSE)

# add global figure to second inset
fig_inset[[2]] <- fig_inset[[2]] +
  annotation_custom(grob = ggplotGrob(fig_smooth),
                    xmin = 649990,
                    xmax = 650045 + (650682 - 650045)/2,
                    ymin = 5903080 - (5903080 - 5902700)/2.5,
                    ymax = 5903080
                    )
  
fig_median_smooth <- 
  wrap_plots(fig_inset)+
  plot_annotation(tag_levels = "a",
                  tag_prefix = "(",
                  tag_suffix = ")")
# save figure
ggsave(filename = "figures/fig_calib_median_smooth.png",
       width = 185 / 25, height = 90 / 25)
```

### Plot pre-processing steps

```{r}
# make combined walkthrough figure
figure_walkthrough <- 
  wrap_plots(
  append(
    list(
      fig_data_bbox, fig_low_nbs, fig_speed_outliers), 
    fig_inset),
design = "ABD\nACE")+
  plot_annotation(tag_levels = "a",
                  tag_prefix = "(",
                  tag_suffix = ")")

# save combined figure
ggsave(figure_walkthrough,
       filename = "figures/fig_walkthrough.png",
       height = 130, width = 225, units = "mm")
```


## Making residence patches

### Prepare data

An indicator of individual residence at or near a position can be useful when attempting to identify residence patches. Positions can be filtered on a metric such as residence time (see Bracis et al. 2018).

In this dataset, residence positions are marked in the `tID` column as beginning with `WP`. These can be extracted and converted into residence patches.

```{r}
# make a data copy
data_unproc <- copy(data)

# assign residence positions
data[, residence := stringi::stri_detect(tID, regex = "WP")]

# make a copy of only residence points
data_res <- data[residence == T, ]
```

### Run residence patch method

```{r}
# on known residence points
patch_res_known <- atl_res_patch(data_res, 
                                buffer_radius = 10,
                                lim_spat_indep = 100,
                                lim_time_indep = 30,
                                min_fixes = 3)
```

### Get spatial and summary objects

```{r}
# for the known and unkniwn patches
patch_sf_data <- atl_patch_summary(patch_res_known, which_data = "spatial")

# assign crs
sf::st_crs(patch_sf_data) <- 32631

# get summary data
patch_summary_data <- atl_patch_summary(patch_res_known, which_data = "summary")
```

### Plot the outcome

```{r}
# patch with residence points and all patches
fig_basic_residence <-
  ggplot()+
  geom_path(data = data,
            aes(x, y),
            lwd = 0.2,
            col = "grey20")+
  geom_point(data = data_res,
             aes(x, y),
             shape = 2,
             size = 2,
             col = pal[2])+
  geom_path(data = patch_summary_data,
            aes(x_median + 200, y_median),
            col = "orange", lty = 1)+
  geom_point(data = patch_summary_data,
             aes(x_median + 200, y_median,
                 fill = duration / 60),
             size = 5,
             shape = 21)+
  
  scale_fill_distiller(palette = "YlOrRd",
                       direction = 1,
                       trans = "log10",
                       limits = c(1, 60))+
  ggthemes::theme_map()+
  theme(legend.position = c(0, 0.3),
        legend.key.width = unit(3, units = "mm"),
        legend.background = element_blank())+
  ggspatial::annotation_scale(location = "tl")+
  coord_sf(crs = 32631)+
  labs(fill = "inferred\nduration (min)")
```

## Compare patch metrics

### Compare known patches

```{r}
# get known patch summary
patch_summary_real <- data_res[, list(nfixes_real = .N,
                                      x_median = round(median(x), digits = -2),
                                      y_median = round(median(y), digits = -2),
                                      duration_real = as.numeric(
                                        max(time) - min(time))), 
                               by = "tID"]

# round median coordinate for inferred patches
patch_summary_inferred <- 
  patch_summary_data[, 
                     c("x_median", "y_median", 
                       "nfixes", "duration")
                     ][, `:=`(x_median = round(x_median, digits = -2),
                              y_median = round(y_median, digits = -2))]

# join with respatch summary
patch_summary_compare <- 
  merge(patch_summary_real,
        patch_summary_inferred, 
        on = c("x_median", "y_median"),
        all.x = TRUE, all.y = TRUE)
```

### Plot durations comparisons

```{r}
# get linear model
model_duration <- lm(duration ~ duration_real,
                     data = patch_summary_compare)

# get R2
summary(model_duration)
```


```{r}
# make figure comparing different methods
figure_patch_duration <-
  ggplot()+
  geom_segment(data = patch_summary_compare,
               aes(x = 100,
                   xend = duration_real,
                   y = duration,
                   yend = duration),
               col = "grey")+
  geom_segment(data = patch_summary_compare,
               aes(x = duration_real,
                   xend = duration_real,
                   y = 100,
                   yend = duration),
               col = "grey")+
  geom_point(data = patch_summary_compare,
             aes(duration_real, 
                 duration),
             show.legend = F,
            size = 3,
            stroke = 1,
            shape = 21,
            fill = pal[2],
            col = "white")+
  geom_smooth(data = patch_summary_compare,
             aes(duration_real, 
                 duration),
             se = F,
             size = 0.5,
             col = pal[1],
             alpha = 0.2,
             method = "glm",
             show.legend = F)+
  annotate(geom = "text",
           x = 300, y = 900,
           size = 5,
           label = "R^2 == 0.845",
           parse = T)+
  scale_x_log10(breaks = c(300, 600, 900),
                labels = as.integer(c(300, 600, 900) / 60))+
  scale_y_log10(breaks = c(300, 600, 900),
                labels = as.integer(c(300, 600, 900) / 60))+
  coord_equal(expand = F,
              xlim = c(200, 1200),
              ylim = c(200, 1200))+
  ggthemes::theme_few()+
  labs(x = "duration (min)",
       y = "inferred duration (min)")
```

### Join patch map and duration comparison figure

```{r}
# wrap together
figure_res_patch <-
  wrap_plots(list(fig_basic_residence, figure_patch_duration))+
    plot_annotation(tag_levels = "a",
                  tag_prefix = "(",
                  tag_suffix = ")") &
  theme(plot.tag = element_text(face = "bold"))

# save figure
ggsave(figure_res_patch,
       filename = "figures/fig_calib_residence_patch.png",
       height = 130, width = 225, units = "mm")
```

