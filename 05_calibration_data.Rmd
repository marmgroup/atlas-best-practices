---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Processing calibration data

## Prepare libraries

```{r}
# load libs
library(data.table)
library(atlastools)
library(ggplot2)
```

## Preliminary visualisation

```{r}
# read and plot example data
data <- fread("data/atlas1060_allTrials_annotated.csv")
data_raw <- copy(data)
# plot data
fig_data_raw <- ggplot(data)+
  geom_path(aes(x, y),
             col = "grey", alpha = 0.5, size = 0.3)+
  geom_point(aes(x, y),
             col = "steelblue", alpha = 0.2, size = 2)+
  ggthemes::theme_map()+
  coord_sf(crs = 32631)

# save figure
ggsave(fig_data_raw, filename = "figures/fig_calibration_raw.png",
       width = 185 / 25)
```

## Filter by bounding box

Save an unprocessed copy.

```{r}
data_unproc <- copy(data)
```

Filter by a bounding box.

```{r}
# remove inside must be set to falses
data <- atl_filter_bounds(data = data, 
                          x = "x", y = "y", 
                          x_range = c(645000, max(data$x)), 
                          remove_inside = FALSE)
```

Plot the result.

```{r}
# plot data
fig_data_bbox <-
  ggplot()+
  geom_path(data = data_unproc,
            aes(x, y),
             col = "grey", alpha = 0.5, size = 0.3)+
  geom_point(data = data_unproc,
             aes(x, y,
                 col = x > 645000),
             alpha = ifelse(data_unproc$x > 645000, 0.5, 1),
             size = ifelse(data_unproc$x > 645000, 0.3, 2),
             show.legend = F)+
  scale_color_brewer(palette = "Set1")+
  geom_vline(xintercept = 645000,
             col = "grey", lty = 2)+
  ggspatial::annotation_scale(location = "br")+
  ggthemes::theme_map()+
  coord_sf(crs = 32631)

# save result
ggsave(fig_data_bbox, filename = "figures/fig_calib_bbox.png",
       width = 185 / 25)
```

### Remove low base station positions

```{r}
# save a copy
data_unproc <- copy(data)

# remove NBS <= 3
data <- atl_filter_covariates(data = data,
                              filters = "NBS > 3")
```

```{r}
fig_low_nbs <-
  ggplot()+
  geom_path(data = data,
            aes(x, y),
             col = "grey", alpha = 0.5, size = 0.3)+
  geom_point(data = data_unproc,
            aes(x, y,
                col = as.factor(NBS > 3)),
            shape = 1,
            alpha = 0.5, size = 0.3, show.legend = F)+
  scale_color_brewer(palette = "Set1")+
  ggthemes::theme_map()+
  ggspatial::annotation_scale(location = "tl")+
  coord_sf(crs = 32631)+
  labs(colour = "NBS")

# save figure
ggsave(fig_low_nbs, filename = "figures/fig_low_nbs.png",
       width = 185 / 25, height = 185 / 25)
```

## Filter trajectories

### Handle time

Time in ATLAS tracking is counted in milliseconds and is represented by a 64-bit integer (type `long`), which is not natively supported in R; it will instead be converted to a `numeric`, or `double`.

This is not what is intended, but it works. The `bit64` package can help handle 64-bit integers if you want to keep to intended type.

A further issue is that 64-bit integers (whether represented as `bit64` or `double`) do not yield meaninful results when you try to convert them to a date-time object, such as of the class `POSIXct`.

This is because `as.POSIXct` fails when trying to work with 64-bit integers (it cannot interpret this type), and returns a date many thousands of years in the future (approx. 52,000 CE) if the time column is converted to `numeric`.

There are two possible solutions. The parsimonious one is to convert the 64-bit number to a 32-bit short integer (dividing by 1000), or to use the `nanotime` package. 

The conversion method loses an imperceptible amount of precision. The `nanotime` requires installing another package. The first method is shown here. 

In the spirit of not destroying data, we create a second lower-case column called `time`.

```{r}
# divide by 1000, convert to integer, then convert to POSIXct
data[, time := as.POSIXct(as.integer(TIME / 1000), 
                          origin = "1970-01-01")]
```

### Add speed and turning angle

```{r}
# add incoming and outgoing speed
data[, `:=` (speed_in = atl_get_speed(data, 
                                      x = "x", 
                                      y = "y", 
                                      time = "time"),
             speed_out = atl_get_speed(data, type = "out"))]

# add turning angle
data[, angle := atl_turning_angle(data = data)]
```

### Get 95th percentile of speed and angle

```{r}
# use sapply
speed_angle_thresholds <- 
  sapply(data[, list(speed_in, speed_out, angle)], 
       quantile, probs = 0.9, na.rm = T)
```

### Plot to see speeds

```{r}
# plot filtered data
fig_speed_outliers <-
  ggplot()+
  geom_path(data = data,
            aes(x, y),
             col = "grey", alpha = 0.5, size = 0.3)+
  geom_point(data = data,
             aes(x, y, 
                 col = speed_in < 15.7),
             size = 0.3, alpha = 0.5,
             show.legend = F)+
  scale_color_brewer(palette = "Set1")+
  ggthemes::theme_map()+
  ggspatial::annotation_scale(location = "tl")+
  coord_sf(crs = 32631)+
  labs(colour = "speed (m/s)")

# save
ggsave(fig_speed_outliers, filename = "figures/fig_speed_outlier.png",
       width = 185 / 25, height = 185 / 25)
```

### Filter on speed

Here we use a speed threshold of 20 m/s, 4 m/s lower than the 95th percentile.

```{r}
# make a copy
data_unproc <- copy(data)

# remove speed outliers
data <- atl_filter_covariates(data = data,
            filters = c("(speed_in < 15.7 & speed_out < 15.7)"))

# recalculate speed and angle
data[, `:=` (speed_in = atl_get_speed(data, 
                                      x = "x", 
                                      y = "y", 
                                      time = "time"),
             speed_out = atl_get_speed(data, type = "out"))]

# add turning angle
data[, angle := atl_turning_angle(data = data)]
```

## Smoothing the trajectory

```{r}
# apply a 5 point median smooth, first make a copy
data_unproc <- copy(data)

# now apply the smooth
data <- atl_median_smooth(data = data,
                          x = "x", y = "y", time = "time",
                          moving_window = 5)
```

```{r}
# make figure
fig_smooth <-
  ggplot()+
  geom_path(data = data,
             aes(x, y),
            col = RColorBrewer::brewer.pal(4, "Set1")[4])+
  annotate(geom = "rect",
           xmin = c(650785, 650045),
           ymin = c(5904450, 5902700),
           xmax = c(652500, 650682),
           ymax = c(5906133, 5903080),
           fill = "grey90",
           alpha = 0.5,
           col = NA)+
    annotate(geom = "text",
           x = c(650785, 650045) + 400,
           y = c(5904450, 5902700) + 300,
           col = "black",
           label = c("(a)", "(b)"))+
  theme_void()+
  coord_sf(crs = 32631)+
  labs(colour = "track")

# make zoomed in figures
fig_inset <- mapply(function(xl, yl) {
  ggplot()+
    geom_point(data = data_raw[!data_unproc, on = c("x", "y")],
               aes(x, y),
               col = "grey",
               shape = 4,
               size = 0.4)+
    geom_point(data = data_unproc,
               aes(x, y),
               col = RColorBrewer::brewer.pal(3, "Set1")[3],
               shape = 1, 
               alpha = 0.5)+
    geom_path(data = data,
              aes(x, y),
              col = RColorBrewer::brewer.pal(4, "Set1")[4])+
    ggthemes::theme_few()+
    theme(axis.title = element_blank(),
          axis.text = element_blank())+
    ggspatial::annotation_scale(location = "br")+
    coord_sf(crs = 32631,
             xlim = xl,
             ylim = yl, expand = F
             )+
    labs(colour = "track")
}, list(xl1 = c(650785, 652500),
        xl2 = c(650045, 650682)),
   list(yl1 = c(5904450, 5906133),
        yl2 = c(5902700, 5903080)),
SIMPLIFY = FALSE)

# add global figure to second inset
fig_inset[[2]] <- fig_inset[[2]] +
  annotation_custom(grob = ggplotGrob(fig_smooth),
                    xmin = 649990,
                    xmax = 650045 + (650682 - 650045)/2,
                    ymin = 5903080 - (5903080 - 5902700)/2.5,
                    ymax = 5903080
                    )
  
wrap_plots(fig_inset)+
  plot_annotation(tag_levels = "a",
                  tag_prefix = "(",
                  tag_suffix = ")")
# save figure
ggsave(filename = "figures/fig_calib_median_smooth.png",
       width = 185 / 25, height = 90 / 25)
```

## Making residence patches

### Prepare data

An indicator of individual residence at or near a position can be useful when attempting to identify residence patches. Positions can be filtered on a metric such as residence time (see Bracis et al. 2018).

In this dataset, residence positions are marked in the `tID` column as beginning with `WP`. These can be extracted and converted into residence patches.

```{r}
# make a data copy
data_unproc <- copy(data)

# assign residence positions
data[, residence := stringi::stri_detect(tID, regex = "WP")]

# make a copy of only residence points
data_res <- data[residence == T, ]

# get a simple inverse of speed as residence time classification
data_slow <- copy(data_unproc)
data_slow <- data_slow[speed_in < 1, ]
```

### Run residence patch method

```{r}
# on known residence points
patch_res_known <- atl_res_patch(data_res, 
                                buffer_radius = 10,
                                lim_spat_indep = 100,
                                lim_time_indep = 30,
                                min_fixes = 3)

# on data where the residence is unknown
patch_res_unknown <- atl_res_patch(data_slow, 
                                buffer_radius = 10,
                                lim_spat_indep = 100,
                                lim_time_indep = 30,
                                min_fixes = 10)
```

### Get spatial and summary objects

```{r}
# for the known and unkniwn patches
patch_sf_data <- lapply(list(patch_res_known, patch_res_unknown),
                        atl_patch_summary, which_data = "spatial")

# assign a crs
patch_sf_data <- lapply(patch_sf_data, function(df) {
  sf::st_crs(df) <- 32631
  return(df)
})

patch_summary_data <- lapply(list(patch_res_known, patch_res_unknown),
                        atl_patch_summary)
```

### Plot the outcome

```{r}
# patch with residence points and walking patches
fig_basic_residence <-
  ggplot()+
  geom_point(data = data,
             aes(x, y,
                 col = residence),
            size = ifelse(data$residence, 4, 0.2),
            shape = ifelse(data$residence, 2, 1),
            show.legend = FALSE)+
  scale_color_brewer(palette = "Set1")+
  ggthemes::theme_map()+
  coord_sf(crs = 32631)

# figure of residence patches known
# fig_patch_known <- 
  ggplot()+
  geom_sf(data = patch_sf_data[[1]],
          fill = "steelblue", col = NA)+
  geom_path(data = patch_summary_data[[1]],
            aes(x_median, y_median),
            col = "red")+
  ggthemes::theme_map()
    
pla = mapply(function(pol) {
  
  bbox = st_bbox(pol)

  ggplot()+
    geom_path(data = data_unproc,
               aes(x, y),
               col = RColorBrewer::brewer.pal(4, "Set1")[4])+
    geom_sf(data = pol,
            alpha = 0.2)+
    ggthemes::theme_map()+
    coord_sf(
      expand = F,
      xlim = c(bbox[["xmin"]], bbox[["xmax"]]),
      ylim = c(bbox[["ymin"]], bbox[["ymax"]]))
}, patch_sf_data[[1]]$polygons, SIMPLIFY = F)

fig_patches_small <- wrap_plots(pla)+
  plot_annotation(tag_levels = "a",
                  tag_prefix = "(",
                  tag_suffix = ")")

# figure of unknown patches
fig_patch_unknown <-
  ggplot()+
  geom_path(data = patch_summary_data[[1]],
            aes(x_median, y_median),
            col = "black", size = 0.2, lty = 2)+
  geom_sf(data = patch_sf_data[[2]],
          fill = "steelblue", col = NA)+
  geom_segment(data = patch_summary_data[[2]],
               aes(x = x_end,
                   xend = shift(x_start, type = "lead"),
                   y = y_end,
                   yend = shift(y_start, type = "lead")),
               col = "red"
  )+
  ggthemes::theme_map()

# arrange plots
fig_res_patch <- 
  wrap_plots(list(fig_basic_residence, fig_patch_known, fig_patch_unknown),
           design = "AAAA\nAAAA\nBBCC\nBBCC")+
  plot_annotation(tag_levels = "a", 
                  tag_prefix = "(", tag_suffix = ")")

# save figure
ggsave(fig_res_patch, filename = "figures/fig_calib_respatch.png",
       height = 200/25, width = 185/25)
```

## Compare patch metrics

### Compare known patches

```{r}
# get known patch summary
patch_summary_real <- data_res[, list(nfixes_real = .N,
                                      x_median = round(median(x), digits = -2),
                                      y_median = round(median(y), digits = -2),
                                      duration_real = as.numeric(
                                        max(time) - min(time))), 
                               by = "tID"]

# round median coordinate for inferred patches
patch_summary_inferred <- 
        patch_summary_data[[1]][, 
                                c("x_median", "y_median", 
                                  "nfixes", "duration")
                                ][, `:=`(x_median = round(x_median, digits = -2),
                                         y_median = round(y_median, digits = -2))]

# join with respatch summary
patch_summary_compare <- 
  merge(patch_summary_real,
        patch_summary_inferred, 
        on = c("x_median", "y_median"),
        all.x = TRUE, all.y = TRUE)
```

### Plot known and unknown patches

```{r}
# make figure comparing different methods
ggplot()+
  geom_point(data = patch_summary_compare,
             aes(duration_real, 
                 duration),
             show.legend = F,
            size = 4,
            shape = 1)+
  geom_smooth(data = patch_summary_compare,
             aes(duration_real, 
                 duration),
             se = F,
             method = "glm",
             show.legend = F)+
  # scale_x_log10()+
  # scale_y_log10()+
  # coord_cartesian(xlim = c(10, NA))+
  ggthemes::theme_few()+
  labs(x = "# positions (real)",
       y = "# positions (inferred)")
```

