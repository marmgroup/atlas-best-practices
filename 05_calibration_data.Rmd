---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Processing calibration data

## Prepare libraries

```{r}
# load libs
library(data.table)
library(atlastools)
library(ggplot2)
library(patchwork)

# prepare a palette
pal <- RColorBrewer::brewer.pal(4, "Set1")
```

## Preliminary visualisation

```{r}
# read and plot example data
data <- fread("data/atlas1060_allTrials_annotated.csv")
data_raw <- copy(data)

# plot data
fig_data_raw <-
  ggplot(data)+
  geom_path(aes(x, y),
             col = "grey", alpha = 0.5, size = 0.3)+
  geom_point(aes(x, y),
             col = pal[3], alpha = 0.2, size = 2)+
  ggthemes::theme_map()+
  coord_sf(crs = 32631)

# save figure
ggsave(fig_data_raw, filename = "figures/fig_calibration_raw.png",
       width = 185 / 25)
```

## Filter by bounding box

Save an unprocessed copy.

```{r}
data_unproc <- copy(data)
```

Filter by a bounding box.

```{r}
# remove inside must be set to falses
data <- atl_filter_bounds(data = data, 
                          x = "x", y = "y", 
                          x_range = c(645000, max(data$x)), 
                          remove_inside = FALSE)
```

Plot the result.

```{r}
# plot data
fig_data_bbox <-
  ggplot()+
  geom_path(data = data_raw,
            aes(x, y),
             col = "grey", alpha = 0.5, size = 0.3)+
  geom_point(data = data_raw,
             aes(x, y,
                 col = x > 645000),
             alpha = ifelse(data_raw$x > 645000, 0.5, 1),
             size = ifelse(data_raw$x > 645000, 0.3, 2),
             show.legend = F)+
  scale_colour_manual(values = c("grey", pal[3]))+
  geom_vline(xintercept = 645000,
             col = "grey", lty = 2)+
  ggspatial::annotation_scale(location = "br")+
  ggthemes::theme_few()+
  theme(axis.text = element_blank(),
        axis.title = element_blank(),
        panel.background = element_rect(fill = "grey99"))+
  coord_sf(crs = 32631)

# save result
ggsave(fig_data_bbox, filename = "figures/fig_calib_bbox.png",
       width = 185 / 25)
```

## Filter trajectories

### Handle time

Time in ATLAS tracking is counted in milliseconds and is represented by a 64-bit integer (type `long`), which is not natively supported in R; it will instead be converted to a `numeric`, or `double`.

This is not what is intended, but it works. The `bit64` package can help handle 64-bit integers if you want to keep to intended type.

A further issue is that 64-bit integers (whether represented as `bit64` or `double`) do not yield meaninful results when you try to convert them to a date-time object, such as of the class `POSIXct`.

This is because `as.POSIXct` fails when trying to work with 64-bit integers (it cannot interpret this type), and returns a date many thousands of years in the future (approx. 52,000 CE) if the time column is converted to `numeric`.

There are two possible solutions. The parsimonious one is to convert the 64-bit number to a 32-bit short integer (dividing by 1000), or to use the `nanotime` package. 

The conversion method loses an imperceptible amount of precision. The `nanotime` requires installing another package. The first method is shown here. 

In the spirit of not destroying data, we create a second lower-case column called `time`.

```{r}
# divide by 1000, convert to integer, then convert to POSIXct
data[, time := as.integer(TIME / 1000)]
```

### Add speed and turning angle

```{r}
# add incoming and outgoing speed
data[, `:=` (speed_in = atl_get_speed(data, 
                                      x = "x", 
                                      y = "y", 
                                      time = "time"),
             speed_out = atl_get_speed(data, type = "out"))]

# add turning angle
data[, angle := atl_turning_angle(data = data)]
```

### Get 95th percentile of speed and angle

```{r}
# use sapply
speed_angle_thresholds <- 
  sapply(data[, list(speed_in, speed_out, angle)], 
       quantile, probs = 0.9, na.rm = T)
```

### Plot to see speeds

```{r}
# plot filtered data
fig_speed_outliers <-
  ggplot()+
  geom_point(data = data,
             aes(x, y, 
                 col = speed_in < 25.6),
             size = 0.3, alpha = 0.5,
             show.legend = F)+
  scale_color_manual(values = c("grey", pal[3]))+
  ggthemes::theme_few()+
  theme(axis.text = element_blank(),
        axis.title = element_blank(),
        panel.background = element_rect(fill = "grey99"))+
  ggspatial::annotation_scale(location = "tl")+
  coord_sf(crs = 32631)+
  labs(colour = "speed (m/s)")

# save
ggsave(fig_speed_outliers, filename = "figures/fig_speed_outlier.png",
       width = 170 / 25, height = 170 / 25)
```

### Filter on speed

Here we use a speed threshold of 25.6 m/s, a little lower than the 95th percentile.

```{r}
# make a copy
data_unproc <- copy(data)

# remove speed outliers
data <- atl_filter_covariates(data = data,
            filters = c("(speed_in < 15 & speed_out < 15)"))

# recalculate speed and angle
data[, `:=` (speed_in = atl_get_speed(data, 
                                      x = "x", 
                                      y = "y", 
                                      time = "time"),
             speed_out = atl_get_speed(data, type = "out"))]

# add turning angle
data[, angle := atl_turning_angle(data = data)]
```

## Smoothing the trajectory

```{r}
# apply a 5 point median smooth, first make a copy
data_unproc <- copy(data)

# now apply the smooth
data <- atl_median_smooth(data = data,
                          x = "x", y = "y", time = "time",
                          moving_window = 5)
```

```{r}
# make figure
# fig_smooth <-
#   ggplot()+
#   geom_path(data = data,
#              aes(x, y),
#             col = RColorBrewer::brewer.pal(4, "Set1")[4])+
#   annotate(geom = "rect",
#            xmin = c(650785, 650045),
#            ymin = c(5904450, 5902700),
#            xmax = c(652500, 650682),
#            ymax = c(5906133, 5903080),
#            fill = "grey90",
#            alpha = 0.5,
#            col = NA)+
#     annotate(geom = "text",
#            x = c(650785, 650045) + 400,
#            y = c(5904450, 5902700) + 300,
#            col = "black",
#            label = c("d", "e"))+
#   theme_void()+
#   coord_sf(crs = 32631)+
#   labs(colour = "track")

# make zoomed in figures
fig_inset <- mapply(function(xl, yl) {
  ggplot()+
    geom_point(data = data_raw[!data_unproc, on = c("x", "y")],
               aes(x, y),
               col = "grey",
               shape = 4,
               size = 0.4)+
    geom_point(data = data_unproc,
               aes(x, y),
               col = pal[3],
               shape = 19, 
               alpha = 0.5)+
    geom_path(data = data,
              aes(x, y),
              col = RColorBrewer::brewer.pal(4, "Set1")[4])+
    ggthemes::theme_few()+
    theme(axis.title = element_blank(),
          axis.text = element_blank())+
    ggspatial::annotation_scale(location = "br")+
    coord_cartesian(
             xlim = xl,
             ylim = yl, expand = F
             )+
    labs(colour = "track")
}, list(xl1 = c(650785, 653250),
        xl2 = c(650045, 650682)),
   list(yl1 = c(5904450, 5906133),
        yl2 = c(5902700, 5903080)),
SIMPLIFY = FALSE)

# # add global figure to second inset
# fig_inset[[2]] <- fig_inset[[2]] +
#   annotation_custom(grob = ggplotGrob(fig_smooth),
#                     xmin = 649990,
#                     xmax = 650045 + (650682 - 650045)/2,
#                     ymin = 5903080 - (5903080 - 5902700)/2.5,
#                     ymax = 5903080
#                     )
  
fig_median_smooth <- fig_inset[[1]]
  # wrap_plots(fig_inset)+
  # plot_annotation(tag_levels = "a",
  #                 tag_prefix = "(",
  #                 tag_suffix = ")")
# save figure
ggsave(fig_median_smooth,
       filename = "figures/fig_calib_median_smooth.png",
       width = 90 / 25, height = 90 / 25)
```

### Plot pre-processing steps

```{r}
# make combined walkthrough figure
figure_walkthrough <-
wrap_plots(
  list(
    fig_data_bbox, fig_speed_outliers, fig_median_smooth),
  design = "AB\nAC")+
  plot_annotation(tag_levels = "a",
                  tag_prefix = "(",
                  tag_suffix = ")")

# save combined figure
ggsave(figure_walkthrough,
       filename = "figures/fig_walkthrough.png",
       height = 130, width = 170, units = "mm")
```


## Making residence patches

### Prepare data

An indicator of individual residence at or near a position can be useful when attempting to identify residence patches. Positions can be filtered on a metric such as residence time (see Bracis et al. 2018).

In this dataset, residence positions are marked in the `tID` column as beginning with `WP`. These can be extracted and converted into residence patches.

```{r}
# make a data copy
data_unproc <- copy(data)
```

### Calculate residence time

Subset for boating segments: 2020-08-24 11:13:00 -- 2020-08-24 12:36:11.

```{r}
# load recurse
library(recurse)
data_recurse <- data_unproc[, list(x, y, time, TAG, UTCtime)]

# filter for boating segment
data_recurse <- atl_filter_covariates(data = data_recurse,
  filters = c("between(UTCtime, '2020-08-24 11:13:00', '2020-08-24 12:36:11')"))

# get 4 column data
data_recurse <- data_recurse[, list(x, y, time, TAG)]

# get recurse data for a 10m radius
recurse_stats <- getRecursions(data_recurse,
                               radius = 500, timeunits = "mins")

# assign to recurse data
data_recurse[, res_time := recurse_stats$residenceTime]
```

### Plot residence time

```{r}
fig_calib_residence <- 
  ggplot()+
  geom_point(data = data_recurse,
             aes(x, y, col = res_time),
             shape = 19, alpha = 0.5,
             show.legend = F)+
  scale_colour_distiller(palette = "Greens", direction = 1,
                         trans = "log10",
                         labels = scales::comma,
                         limits = c(5, NA),
                         na.value = "grey")+
  ggspatial::annotation_scale(location = "br")+
  ggthemes::theme_few()+
  theme(axis.text = element_blank(),
        axis.title = element_blank(),
        panel.background = element_rect(fill = "grey99"))+
  coord_sf(crs = 32631)
```


### Run residence patch method

```{r}
# assign id as tag
data_recurse[, id := as.character(TAG)]

# subset on 5 minute residence time
data_recurse_subset <- data_recurse[res_time >= 5, ]

# on known residence points
patch_res_known <- atl_res_patch(data_recurse_subset, 
                                buffer_radius = 5,
                                lim_spat_indep = 100,
                                lim_time_indep = 30,
                                min_fixes = 3)
```

### Get spatial and summary objects

```{r}
# for the known and unkniwn patches
patch_sf_data <- atl_patch_summary(patch_res_known, which_data = "spatial")

# assign crs
sf::st_crs(patch_sf_data) <- 32631

# get summary data
patch_summary_data <- atl_patch_summary(patch_res_known, which_data = "summary")
```

### Plot the outcome

```{r}
# patch with residence points and all patches
fig_basic_residence <-
  ggplot()+
  geom_point(data = data_recurse,
            aes(x, y,
                col = res_time > 5),
            show.legend = F,
            size = 1)+
  geom_path(data = patch_summary_data,
            aes(x_median, y_median),
            col = pal[4], lty = 1)+
  geom_point(data = patch_summary_data,
             aes(x_median, y_median),
             size = 10,
             stroke = 2,
             col = pal[4],
             shape = 1,
             show.legend = F)+
  scale_colour_manual(values = c("grey", pal[3]))+
  scale_fill_distiller(palette = "RdPu")+
  ggspatial::annotation_scale(location = "tl")+
  ggthemes::theme_few()+
  theme(axis.text = element_blank(),
        axis.title = element_blank(),
        panel.background = element_rect(fill = "grey99"))+
  coord_sf(crs = 32631,
           xlim = c(NA, 650000))
```

## Compare patch metrics

### Compare known patches

```{r}
# get known patch summary
data_res <- data_unproc[stringi::stri_detect(tID, regex = "(WP)"), ]
# filter for boating
data_res <- data_res[between(UTCtime, '2020-08-24 11:13:00', '2020-08-24 12:36:11'), ]

# get waypoint summary
patch_summary_real <- data_res[, list(nfixes_real = .N,
                                      x_median = round(median(x), digits = -2),
                                      y_median = round(median(y), digits = -2),
                                      duration_real = as.numeric(
                                        max(time) - min(time))), 
                               by = "tID"]

# round median coordinate for inferred patches
patch_summary_inferred <- 
  patch_summary_data[, 
                     c("x_median", "y_median", 
                       "nfixes", "duration")
                     ][, `:=`(x_median = round(x_median, digits = -2),
                              y_median = round(y_median, digits = -2))]

# join with respatch summary
patch_summary_compare <- 
  merge(patch_summary_real,
        patch_summary_inferred, 
        on = c("x_median", "y_median"),
        all.x = TRUE, all.y = TRUE)
```

### Plot durations comparisons

```{r}
# get linear model
model_duration <- lm(duration_real ~ duration,
                     data = patch_summary_compare)

# get R2
summary(model_duration)
```


```{r}
# make figure comparing different methods
# figure_patch_duration <-
  ggplot()+
  geom_point(data = patch_summary_compare,
             aes(duration, 
                 duration_real),
             show.legend = F,
            size = 3,
            stroke = 1,
            shape = 21,
            fill = pal[2],
            col = "white")+
  geom_smooth(data = patch_summary_compare,
             aes(duration, 
                 duration_real),
             se = F,
             size = 0.5,
             col = pal[1],
             alpha = 0.2,
             method = "glm",
             show.legend = F)+
  annotate(geom = "text",
           x = 500, y = 320,
           size = 5,
           label = "R^2 == 0.849",
           parse = T)+
  # scale_x_log10(breaks = c(300, 600, 900),
  #               labels = as.integer(c(300, 600, 900) / 60))+
  # scale_y_log10(breaks = c(300, 600, 900),
  #               labels = as.integer(c(300, 600, 900) / 60))+
  # coord_equal(expand = F)+
  ggthemes::theme_few()+
  labs(x = "inferred duration (min)",
       y = "real duration (min)")
```

### Join patch map and duration comparison figure

```{r}
# wrap together
figure_res_patch <-
  wrap_plots(list(fig_basic_residence, figure_patch_duration))+
    plot_annotation(tag_levels = "a",
                  tag_prefix = "(",
                  tag_suffix = ")") &
  theme(plot.tag = element_text(face = "bold"))

# save figure
ggsave(figure_res_patch,
       filename = "figures/fig_calib_residence_patch.png",
       height = 130, width = 225, units = "mm")
```
